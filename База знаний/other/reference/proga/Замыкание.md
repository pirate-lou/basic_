---
создал заметку: 2024-04-21
tags:
  - замыкание
  - программирование
---
__Замыкание__ (closure) представляет объект функции, который запоминает свое лексическое окружение даже в том случае, когда она выполняется вне своей области видимости.

Технически замыкание включает три компонента:

- внешняя функция, которая определяет некоторую область видимости и в которой определены некоторые переменные и параметры - лексическое окружение
    
- переменные и параметры (лексическое окружение), которые определены во внешней функции
    
- вложенная функция, которая использует переменные и параметры внешней функции

```c#
var fn = Outer(); // fn = Inner, так как метод Outer возвращает функцию Inner
// вызываем внутреннюю функцию Inner
fn();   // 6
fn();   // 7
fn();   // 8
Action Outer() // метод или внешняя функция
{
    int x = 5;  // лексическое окружение - локальная переменная
    void Inner()    // локальная функция
    {
        x++;        // операции с лексическим окружением
        Console.WriteLine(x);
    }
    return Inner;   // возвращаем локальную функцию
}
```
Здесь метод `Outer` в качестве возвращаемого типа имеет тип `Action`, то есть метод возвратить функцию, которая не принимает параметров и имеет тип void.
```c#
Action Outer()
```
Внутри метода `Outer` определена переменная `x` - это и есть лексическое окружение для внутренней функции:
```c#
int x = 5;
```
Также внутри метода `Outer` определена внутренняя функция - локальная функция `Inner`, которая обращается к своему лексическому окружению - переменной x - увеличивает ее значение на единицу и выводит на консоль:
```c#
void Inner()
{
	x++;
	Console.WriteLine(x);
}
```
Эта локальная функция возвращается методом `Outer`:
```c#
return Inner;
```
В программе вызываем метод `Outer` и получаем в переменную `fn` локальную функцию `Inner`:
```c#
var fn = Outer();
```
Переменная `fn` и представляет собой замыкание, то есть объединяет две вещи: функцию и окружение, в котором функция была создана. И несмотря на то, что мы получили локальную функцию и можем ее вызывать вне ее метода, в котором она определена, тем не менее она запомнила свое лексическое окружение и может к нему обращаться и изменять, что мы увидим по консольному выводу:
```c#
fn();   // 6
fn();   // 7
fn();   // 8
```
__Реализация при помощи лямбда-выражений__
```c#
var outerFn = () =>
{
    int x = 10;
    var innerFn = () => Console.WriteLine(++x);
    return innerFn;
};
var fn = outerFn();   // fn = innerFn, так как outerFn возвращает innerFn`
// вызываем innerFn
fn();   // 6
fn();   // 7
fn();   // 8
```














==Замыкание== - это ситуация, когда в лямбда-выражении используется переменная из другого метода

*Анонимный делегат - синтаксический сахар, который позволяет создать метод за нас*
```c#
static void Main()
{
	var strings = new[] { "A", "B", "AA" };
	bool Descending = true;
	Func<string, string, int> comparer =
		(x, y) => x.CompareTo(y) * (Descending ? -1 : 1);
	Sort(strings, comparer);
	Descending = false;
	Sort(strings, comparer);
}
```
- можно использовать локальные переменные, чтобы манипулировать поведением лямбда-выражений

- Как работает замыкание
	 [[карта памяти]]
- `Target` - указывает на анонимный объект, внутри которого содержится поле `Desc(true/false)`
- `Descending`(в методе `Main()`) - это ссылка на поле внутри анонимного объекта

Что происходит???
	 когда компилятор видит, что некоторые переменные  используются в замыкании, как `Descending`, компилятор создает анонимный тип (как и анонимный метод, т.е. метод без имени) это тип, который вы нигде не определяли, компилятор сам пишет ему класс и придумывает имя.
	В этом анонимном типе он определяет поля, которые соответствуют всем переменным используемым в замыкании (в нашем случае только поле `Descending`)
	 Когда эти переменные продолжают дальше использоваться как локальные переменные, они подменяются, их изменение приводит к тому, что изменяются соответствующие поля внутри объекта анонимного типа. 
	 А лямбда-выражение, которое использует переменные замыкания превращается не в статический метод, а в динамический. И объектом, из которого вызывается эта лямбда, является тот самый объект анонимного типа 
	Таким образом позволяет нам осуществлять связь между методом Main() и Лямбда-выражением, потому что изменяя локальные переменные метода Main(), мы на самом деле изменяем поля анонимного объекта и потом, когда мы вызывает лямбду, она смотрит на те же самые поля и изменяет свое поведение, таким образом не происходит такого, что один метод смотрит локальные переменные другого метода. 
	
Что происходит на самом деле? - это то что локальные переменные, которые разделены между двумя методами которые должны быть видны в обоих методах, эти локальные переменные переезжают в анонимный тип. Соответственно метод `Main()` меняет не свои локальные переменные, а эти поля:
![[Screenshot 2024-04-21 at 4.46.43 PM.png]]
	И второй метод, анонимный метод, который был получен из лямбда-выражений, смотрит на эти поля и поэтому это все работает. 
	
- Компилятор на самом деле пишет что-то похожее на это: 
```c#
public class AlphabetComparer
{
	public bool Descending { get; set; }
	public int Compare(string x, string y)
	{
		return x.Length.CompareTo(y) * (Descending ? -1 : 1);
	}
}
```
*имена AlphabetComparer и Compare придумываются компилятором*

Замыкания хорошо показать на примере `foreach(var e in list) {...}`
